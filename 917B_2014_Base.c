#pragma config(Motor,  port5,           leftBackMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           leftFrontMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port3,           rightFrontMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port4,           rightBackMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6, 					armBotMotors, tmotorVex393, openLoop)
#pragma config(Motor,  port7,						armTopMotors, tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//                                      Variables																			 //
/////////////////////////////////////////////////////////////////////////////////////////

int ARM_BOTTOM_DOWN;
int ARM_BOTTOM_UP;
int ARM_BOTTOM_HOLD;
int ARM_BOTTOM_HOLD_POWER = 30;
int ARM_TOP_DOWN;
int ARM_TOP_UP;
int ARM_TOP_HOLD;
int ARM_TOP_HOLD_POWER = 30;


/////////////////////////////////////////////////////////////////////////////////////////
//                                      Functions																			 //
/////////////////////////////////////////////////////////////////////////////////////////

float cubeScaling(float inValue){
		float returnValue;
		returnValue = pow(inValue, 3) / pow(127, 3);
		return returnValue;
}

void forwardNoRamp(float x, float y, float time){

}

void turnNoRamp(float t, float time){

}


void pre_auton()
{

  	bStopTasksBetweenModes = true;

}

/////////////////////////////////////////////////////////////////////////////////////////
//                                 Autonomous Task																	   //
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

		AutonomousCodePlaceholderForTesting();

}

////////////////////////////////////////////////////////////////////////////////////////
//                                 User Control Task
/////////////////////////////////////////////////////////////////////////////////////////

task arm(){
		float botArmPower,topArmPower; //Power values
		float botArmPos, topArmPos; //Potentiometer values
		float armPower = 80;
		float armAngleDiffMax = 200;
		while(true){
				botArmPower = armPower * (-1 * vexRT[Btn5D] + vexRT[Btn5U]);
				topArmPower = armPower * (-1 * vexRT[Btn6D] + vexRT[Btn6U]);

				if(botArmPower == 0){
						botArmPower = ARM_BOTTOM_HOLD_POWER;
			  }
			  if(topArmPower == 0){
			  		topArmPower = ARM_TOP_HOLD_POWER;
			  }
			  motor[armBotMotors] = botArmPower;
				motor[armTopMotors] = topArmPower;


		}
}

task drive()
{
		//J-axis is front-left
		//K-axis is front-right
		float jAxis, kAxis, lAxis;
		float powerFL, powerFR, powerBL, powerBR;
		float basePowerFL, basePowerFR, basePowerBL, basePowerBR;
		float turnPercent;
		int turnDirection;
		while (true)
		{
				jAxis = vexRT[Ch4] * 0.5 + vexRT[Ch3] * -0.5;
				kAxis = vexRT[Ch4] * 0.5 + vexRT[Ch3] * 0.5;
				lAxis = vexRT[Ch1];

				//cubic scaling on turn ratio for smoother turning
				turnPercent = abs(cubeScaling(lAxis));
				turnDirection = lAxis / abs(lAxis);

				basePowerFR = (1 - turnPercent) * jAxis;
				basePowerBL = (1 - turnPercent) * jAxis;
				basePowerFL = (1 - turnPercent) * kAxis;
				basePowerBR = (1 - turnPercent) * kAxis;

				powerFR = basePowerFR + turnPercent * turnDirection * 127;
				powerBL = basePowerBL + turnPercent * turnDirection * -127;
				powerFL = basePowerFL + turnPercent * turnDirection * 127;
				powerBR = basePowerBR + turnPercent * turnDirection * -127;


				motor[leftBackMotor] = powerBL;
				motor[leftFrontMotor] = powerFL;
				motor[rightBackMotor] = powerBR;
				motor[rightFrontMotor] = powerFR;


				if(vexRT[Btn7U] == 1){
						writeDebugStream("%f", jAxis);
						writeDebugStream(" ");
						writeDebugStream("%f", kAxis);
						writeDebugStream(" ");
						writeDebugStream("%f", lAxis);
						writeDebugStreamLine(" ");
				}
		}

		//Don't forget to assign powers to the motors!

}


task usercontrol()
{
		StartTask(drive);
		StartTask(arm);
}
