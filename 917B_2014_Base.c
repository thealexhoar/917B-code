#pragma config(Sensor, in1,    topPot,         sensorPotentiometer)
#pragma config(Sensor, in2,    botPot,         sensorPotentiometer)
#pragma config(Motor,  port8,           leftFrontMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port2,           rightFrontMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port4,           rightBackMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           leftBackMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           armRightMotors,  tmotorVex393, openLoop)
#pragma config(Motor,  port6,           armLeftMotors,  tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           clawMotor,     tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//                                      Variables																			 //
/////////////////////////////////////////////////////////////////////////////////////////

int ARM_BOTTOM_DOWN = 1390;
int ARM_BOTTOM_UP = 3300;
int ARM_BOTTOM_HOLD = 1750;
int ARM_BOTTOM_HOLD_POWER = 20; //10
int ARM_TOP_DOWN = 1420;
int ARM_TOP_UP = 2860;
int ARM_TOP_HOLD = 1500;
int ARM_TOP_HOLD_POWER = 10; //10

float MAX_BOT = 3000, MIN_BOT = 1390; // keep three sigfigs
float MAX_TOP = 2700, MIN_TOP = 1420;
// Date is 6th of Dec and values are 1300, 1300, 2900 and 1300

/////////////////////////////////////////////////////////////////////////////////////////
//                                      Functions																			 //
/////////////////////////////////////////////////////////////////////////////////////////

float cubeScaling(float inValue)
{
		return pow(inValue, 3) / pow(127, 3);
}
/*
void liftTopArm(int potValue = ARM_TOP_HOLD + 200){
		while(SensorValue[topPot] < potValue){
				motor[armTopMotors] = 60;
		}
		motor[armTopMotors] = 10;
}

void lowerTopArm(int potValue = ARM_TOP_DOWN){
		while(SensorValue[topPot] > potValue){
				motor[armTopMotors] = -30;
		}
		motor[armTopMotors] = 0;
}

void liftBotArm(int potValue = ARM_BOTTOM_HOLD + 500){
		while(SensorValue[botPot] < potValue){
				motor[armBotMotors] = 100;
		}
		motor[armBotMotors] = 20;
}

void lowerBotArm(int potValue = ARM_BOTTOM_DOWN){
		while(SensorValue[botPot] > potValue){
				motor[armBotMotors] = -30;
		}
		motor[armBotMotors] = 0;
}*/


void forwardNoRamp(float x, float y, float time, float power = 100)
{
				float jAxis = x * 0.5 + y * -0.5;
				float kAxis = x * 0.5 + y * 0.5;

				motor[leftBackMotor] = jAxis * power;
				motor[leftFrontMotor] = kAxis * power;
				motor[rightBackMotor] = kAxis * power;
				motor[rightFrontMotor] = jAxis * power;
				wait1Msec(time);

				motor[leftBackMotor] =  0;
				motor[leftFrontMotor] = 0;
				motor[rightBackMotor] = 0;
				motor[rightFrontMotor] = 0;

}

void turnNoRamp(float t, float time, float power = 80)
{
		motor[rightFrontMotor] = t * power;
		motor[leftBackMotor] = t * power * -1;
		motor[leftFrontMotor] = t * power;
		motor[rightBackMotor] = t * power * -1;

		wait1Msec(time);
		motor[leftBackMotor] =  0;
		motor[leftFrontMotor] = 0;
		motor[rightBackMotor] = 0;
		motor[rightFrontMotor] = 0;
}

void pre_auton()
{


}

/////////////////////////////////////////////////////////////////////////////////////////
//                                 Autonomous Task																	   //
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

		forwardNoRamp(0,1,2000);
		turnNoRamp(1, 800);

}

////////////////////////////////////////////////////////////////////////////////////////
//                                 User Control Task																	//
////////////////////////////////////////////////////////////////////////////////////////

task claw()
{

		float clawMotorPower = 64;
		int waitTime = 500;

		while(true){
				if(vexRT[Btn7R] == 1){ //unclench
						motor[clawMotor] = -clawMotorPower;
						wait1Msec(waitTime);
						motor[clawMotor] = 0;
				}
				else if(vexRT[Btn7L] == 1){//clench
						motor[clawMotor] = clawMotorPower;
						wait1Msec(waitTime);
						motor[clawMotor] = 0;
				}
				else if(vexRT[Btn7D] == 1){ //clench and hold
						motor[clawMotor] = clawMotorPower;
						while(vexRT[Btn7U] != 1){

						}
						motor[clawMotor] = -clawMotorPower;
						wait10Msec(waitTime);
						motor[clawMotor] = 0;
				}
		}
}


task arm()
{
	  float armPower = 80; //Power values
		float armPos; 			 //Potentiometer values
		int armDir = 0;
		while(true)
		{
				armDir = vexRT[Btn6U] - vexRT[Btn6D];
				motor[armLeftMotors] = armDir * armPower;
				motor[armRightMotors] = armDir * armPower;
		}
}

// TODO: IMPLEMENT THRESHOLD VALUES
task drive()
{
		//J-axis is front-left
		//K-axis is front-right
		float jAxis, kAxis, lAxis;
		float powerFL, powerFR, powerBL, powerBR;
		float basePowerFL, basePowerFR, basePowerBL, basePowerBR;
		float turnPercent;
		int turnDirection;
		float clutchZone = 50;
		while (true)
		{
				jAxis = vexRT[Ch4] * 0.5 + vexRT[Ch3] * -0.5;
				kAxis = vexRT[Ch4] * 0.5 + vexRT[Ch3] * 0.5;
				lAxis = vexRT[Ch1];

				//cubic scaling on turn ratio for smoother turning
				turnPercent = abs(cubeScaling(lAxis));
				turnDirection = lAxis / abs(lAxis);

				if(abs(jAxis) - abs(kAxis) >= clutchZone){  //Zone to 'pull' drifting stick motion to the axes
						float avg = (abs(jAxis) + abs(kAxis)) / 2; // average j,k values
						float jDir, kDir;  // either 1 or -1
						jDir = jAxis / abs(jAxis);
						kDir = kAxis / abs(kAxis);

				}

				basePowerFR = (1 - turnPercent) * jAxis;
				basePowerBL = (1 - turnPercent) * jAxis;
				basePowerFL = (1 - turnPercent) * kAxis;
				basePowerBR = (1 - turnPercent) * kAxis;


				powerFR = basePowerFR + turnPercent * turnDirection * 127;
				powerBL = basePowerBL + turnPercent * turnDirection * -127;
				powerFL = basePowerFL + turnPercent * turnDirection * 127;
				powerBR = basePowerBR + turnPercent * turnDirection * -127;


				motor[leftBackMotor] = powerBL;
				motor[leftFrontMotor] = powerFL;
				motor[rightBackMotor] = powerBR;
				motor[rightFrontMotor] = powerFR;


				if(vexRT[Btn7U] == 1){
						writeDebugStream("%f", jAxis);
						writeDebugStream(" ");
						writeDebugStream("%f", kAxis);
						writeDebugStream(" ");
						writeDebugStream("%f", lAxis);
						writeDebugStreamLine(" ");
				}
		}

		//Don't forget to assign powers to the motors!

}

task autonTest()
{
		while(true){
				if(vexRT[Btn7U] == 1){
						forwardNoRamp(0,1,200);
				}
				if(vexRT[Btn7D] == 1){
					//liftTopArm();
				}
				if(vexRT[Btn7R] == 1){
						//autonRedNoPeg();
				}
				if(vexRT[Btn7L] == 1){
	      		//autonBlueNoPeg();
	    	}
		}
}


task usercontrol()
{
		//StartTask(claw);
		StartTask(drive);
		StartTask(arm);

		StartTask(autonTest);
}
